desc:       MIDI Sample Namer
version:    1.0
author:     denybear
tags:       midi samples naming 
//link:       https://github.com/chkhld/jsfx/
//screenshot: https://github.com/chkhld/jsfx/blob/main/assets/screenshots/midi_chord_trigger.png
about:
 # MIDI Sample Namer
 
 The idea is to have a single playable octave of root notes, and control the
 type of chord these root notes trigger, as well as the MIDI octave on which
 these chords are triggered, from two other sections on the keyboard.

// ----------------------------------------------------------------------------


//slider1:albums=0<0,5,1{DSOTM,WYWH,ANIMALS,DIVISION BELL,MEDDLE,OTHER}>Album names


@init
  
  // Various MIDI codes for better readability
  MIDI_note_off = 0x80;
  MIDI_note_on  = 0x90;
  MIDI_CC = 0xB0;


@slider
  
@block
  
  // Cycle through incoming MIDI messages
  while(midirecv(offset, msg1, msg2) ?
  (
    // Flag to avoid notes outside the designated sections playing (and sticking!)
    note_was_handled = 0;
    
    // Extract note properties
    status   = msg1 & $xF0; // Message type
    channel  = msg1 & $x0F; // Input channel
    note     = msg2 & $x7F; // Note number
    velocity = msg2 >> 8;   // Note velocity

	// test whether this is note-on, note-off or CC

	// if CC
	

	// if note-on
	(album == "WYWH") ? (
		note==60 ? (		// C3
			sample = "Run Forest";
			noteToPlay = 0x10;
		);
		note==62 ? (		// D3
			sample = "Run Forest";
			noteToPlay = 0x11;
		);
    );
	(album == "DSOTM") ? (
		note==60 ? (		// C3
			sample = "Run Forest";
			noteToPlay = 0x10;
		);
		note==62 ? (		// D3
			sample = "Run Forest";
			noteToPlay = 0x11;
		);
    );

    
    // If an octave switching key was pressed
    (note >= ks_octave_lo && note <= ks_octave_hi) ?
    (
      // Update root octave number
      root_octave = note - ks_octave_lo;
      
      // 12 notes in an octave * root octave number
      note_octave = root_octave * 12;
      
      // Flag that this note input was processed
      note_was_handled = 1;
    );
    
    // If a chord switching key was pressed
    (note >= ks_chord_lo && note <= ks_chord_hi) ?
    (
      // Key offset inside the range of 12 chord switching keys
      chord_switch_nr = note - ks_chord_lo;
      
      // Flag that this note input was processed
      note_was_handled = 1;
    );
    
    // Update chord type
    chord_type = chord_types[chord_switch_nr];
    
    // If an actual root note key was pressed
    (note >= ks_root_lo && note <= ks_root_hi) ? 
    (
      // If the PLAYING NOTE on the PLAYING CHANNEL receives a NOTE ON or NOTE OFF message, or
      // If a DIFFERENT NOTE on any OTHER CHANNELS receives a NOTE ON message
      ((note == playing_notes[root] && channel == playing_channel && (status == MIDI_note_on || status == MIDI_note_off)) || 
       (note != playing_notes[root] && status  == MIDI_note_on)) ?
      (
        // Iterator for loop below
        chord_note_nr = 0;
        
        // Cycle through all "playing partial note" buffers
        while (chord_note_nr < chord_notes)
        (
          // If a note at this partial position is currently already playing
          (playing_notes[chord_note_nr] != none) ?
          (
            // Send a MIDI note off command for this partial note (on the old channel)
            midisend(offset, MIDI_note_off | playing_channel, playing_notes[chord_note_nr] | (velocity << 8));
            
            // Reset the "note playing" flag for this partial chord note
            playing_notes[chord_note_nr] = none;
          );
          
          // Increment iterator and step to next note in chord
          chord_note_nr = chord_note_nr + 1;
        );
      );
      
      // Update the "currently playing on channel nr" buffer variable
      playing_channel = channel;
      
      // Figure out the offset of the pressed root key inside the root key range
      root_offset = note - ks_root_lo;
      
      // Iterator for loop below
      chord_note_nr = 0;
      
      // Cycle through all note buffers
      while (chord_note_nr < chord_notes)
      (
        // The offset of this partial chord note in relation to the root note
        partial_offset = chords[chord_type + chord_note_nr];
        
        // If this partial chord note has an actual offset assigned
        (partial_offset != none) ?
        (
          // Calculate the MIDI note nr of this partial chord note
          midi_note_nr = note_octave + root_offset + partial_offset;
          
          // If the calculated MIDI note number is inside the valid note range
          (midi_note_nr < 128) ?
          (
            // Send the MIDI message out
            midisend(offset, msg1, midi_note_nr | (velocity << 8));
            
            // Mark this partial's MIDI note number as "currently playing"
            playing_notes[chord_note_nr] = midi_note_nr;
          )
          : // If the calculated MIDI note for this partial is outside the valid note range
          (
            // Increase "note of chord" iterator to be out of bounds i.e. escape loop
            chord_note_nr = 6;
          );
        );
        
        // Increment "note of chord" interator
        chord_note_nr = chord_note_nr + 1;
      );
      
      // Flag that this note input was processed
      note_was_handled = 1;
    );
    
    // If the incoming note was NOT handled by one of the previous blocks i.e. it's out of bounds
    (note_was_handled == 0) ?
    (
      // Send the MIDI message out to stop this note
      midisend(offset, MIDI_note_off | channel, note | (velocity << 8));
    );
  ));
  
@sample

@gfx
